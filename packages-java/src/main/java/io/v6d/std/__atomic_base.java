// Code generated by alibaba/fastFFI. DO NOT EDIT.
//
package io.v6d.std;

import com.alibaba.fastffi.CXXHead;
import com.alibaba.fastffi.CXXReference;
import com.alibaba.fastffi.CXXValue;
import com.alibaba.fastffi.FFIFactory;
import com.alibaba.fastffi.FFIGen;
import com.alibaba.fastffi.FFIGetter;
import com.alibaba.fastffi.FFINameAlias;
import com.alibaba.fastffi.FFIPointer;
import com.alibaba.fastffi.FFISetter;
import com.alibaba.fastffi.FFITypeAlias;
import com.alibaba.fastffi.FFITypeFactory;
import java.lang.Class;
import java.lang.ClassNotFoundException;
import java.lang.IllegalAccessException;
import java.lang.InstantiationException;
import java.lang.Long;
import java.lang.NoSuchMethodException;
import java.lang.reflect.InvocationTargetException;

@FFITypeAlias("std::__atomic_base")
@FFIGen
@CXXHead(
        system = "atomic"
)
public interface __atomic_base<_Tp> extends FFIPointer {
    @FFISetter
    void __a_(@CXXReference __cxx_atomic_impl<_Tp> value);

    @FFIGetter
    @CXXReference
    __cxx_atomic_impl<_Tp> __a_();

    boolean is_lock_free();

    @FFINameAlias("is_lock_free")
    boolean is_lock_free_1();

    void store(@CXXValue _Tp __d, @CXXValue memory_order __m);

    @FFINameAlias("store")
    void store_1(@CXXValue _Tp __d, @CXXValue memory_order __m);

    @CXXValue
    _Tp load(@CXXValue memory_order __m);

    @CXXValue
    @FFINameAlias("load")
    _Tp load_1(@CXXValue memory_order __m);

    @CXXValue
    _Tp exchange(@CXXValue _Tp __d, @CXXValue memory_order __m);

    @CXXValue
    @FFINameAlias("exchange")
    _Tp exchange_1(@CXXValue _Tp __d, @CXXValue memory_order __m);

    boolean compare_exchange_weak(@CXXReference _Tp __e, @CXXValue _Tp __d,
            @CXXValue memory_order __s, @CXXValue memory_order __f);

    @FFINameAlias("compare_exchange_weak")
    boolean compare_exchange_weak_1(@CXXReference _Tp __e, @CXXValue _Tp __d,
            @CXXValue memory_order __s, @CXXValue memory_order __f);

    boolean compare_exchange_strong(@CXXReference _Tp __e, @CXXValue _Tp __d,
            @CXXValue memory_order __s, @CXXValue memory_order __f);

    @FFINameAlias("compare_exchange_strong")
    boolean compare_exchange_strong_1(@CXXReference _Tp __e, @CXXValue _Tp __d,
            @CXXValue memory_order __s, @CXXValue memory_order __f);

    boolean compare_exchange_weak(@CXXReference _Tp __e, @CXXValue _Tp __d,
            @CXXValue memory_order __m);

    @FFINameAlias("compare_exchange_weak")
    boolean compare_exchange_weak_1(@CXXReference _Tp __e, @CXXValue _Tp __d,
            @CXXValue memory_order __m);

    boolean compare_exchange_strong(@CXXReference _Tp __e, @CXXValue _Tp __d,
            @CXXValue memory_order __m);

    @FFINameAlias("compare_exchange_strong")
    boolean compare_exchange_strong_1(@CXXReference _Tp __e, @CXXValue _Tp __d,
            @CXXValue memory_order __m);

    void wait(@CXXValue _Tp __v, @CXXValue memory_order __m);

    @FFINameAlias("wait")
    void wait_1(@CXXValue _Tp __v, @CXXValue memory_order __m);

    void notify_one();

    @FFINameAlias("notify_one")
    void notify_one_1();

    void notify_all();

    @FFINameAlias("notify_all")
    void notify_all_1();

    static <_Tp> __atomic_base<_Tp> cast(Class<_Tp> ___tp, final long __foreign_address) {
        try {
            Class<__atomic_base<_Tp>> clz = (Class<__atomic_base<_Tp>>) FFITypeFactory.getType(FFITypeFactory.getFFITypeName(FFITypeFactory.makeParameterizedType(__atomic_base.class, ___tp), true));
            return clz.getConstructor(Long.TYPE).newInstance(__foreign_address);
        } catch (ClassNotFoundException | NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) {
            return null;
        }
    }

    static <_Tp> __atomic_base<_Tp> cast(Class<_Tp> ___tp, final FFIPointer __foreign_pointer) {
        return __atomic_base.cast(___tp, __foreign_pointer.getAddress());
    }

    static <_Tp> Factory<_Tp> getFactory(Class<_Tp> ___tp) {
        return FFITypeFactory.getFactory(FFITypeFactory.getFFITypeName(FFITypeFactory.makeParameterizedType(__atomic_base.class, ___tp), true));
    }

    static <_Tp> __atomic_base<_Tp> create(Class<_Tp> ___tp, @CXXValue _Tp __d) {
        return __atomic_base.getFactory(___tp).create(__d);
    }

    @FFIFactory
    @CXXHead(
            system = "atomic"
    )
    interface Factory<_Tp> {
        __atomic_base<_Tp> create(@CXXValue _Tp __d);
    }
}
