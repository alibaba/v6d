// Code generated by alibaba/fastFFI. DO NOT EDIT.
//
package io.v6d.vineyard;

import com.alibaba.fastffi.CXXEnum;
import com.alibaba.fastffi.CXXEnumMap;
import com.alibaba.fastffi.CXXHead;
import com.alibaba.fastffi.FFIGen;
import com.alibaba.fastffi.FFIGetter;
import com.alibaba.fastffi.FFILibrary;
import com.alibaba.fastffi.FFIPointer;
import com.alibaba.fastffi.FFITypeAlias;
import com.alibaba.fastffi.FFITypeFactory;
import com.alibaba.fastffi.FFITypeRefiner;
import io.v6d.std.CInt;
import java.lang.Class;
import java.lang.ClassNotFoundException;
import java.lang.IllegalAccessException;
import java.lang.InstantiationException;
import java.lang.Long;
import java.lang.NoSuchMethodException;
import java.lang.reflect.InvocationTargetException;

@FFITypeAlias("vineyard::StatusCode")
@FFITypeRefiner("io.v6d.vineyard.StatusCode.get")
@CXXHead("common/util/status.h")
public enum StatusCode implements CXXEnum {
    kOK(Library.INSTANCE.kOK()),

    kInvalid(Library.INSTANCE.kInvalid()),

    kKeyError(Library.INSTANCE.kKeyError()),

    kTypeError(Library.INSTANCE.kTypeError()),

    kIOError(Library.INSTANCE.kIOError()),

    kEndOfFile(Library.INSTANCE.kEndOfFile()),

    kNotImplemented(Library.INSTANCE.kNotImplemented()),

    kAssertionFailed(Library.INSTANCE.kAssertionFailed()),

    kUserInputError(Library.INSTANCE.kUserInputError()),

    kObjectExists(Library.INSTANCE.kObjectExists()),

    kObjectNotExists(Library.INSTANCE.kObjectNotExists()),

    kObjectSealed(Library.INSTANCE.kObjectSealed()),

    kObjectNotSealed(Library.INSTANCE.kObjectNotSealed()),

    kObjectIsBlob(Library.INSTANCE.kObjectIsBlob()),

    kMetaTreeInvalid(Library.INSTANCE.kMetaTreeInvalid()),

    kMetaTreeTypeInvalid(Library.INSTANCE.kMetaTreeTypeInvalid()),

    kMetaTreeTypeNotExists(Library.INSTANCE.kMetaTreeTypeNotExists()),

    kMetaTreeNameInvalid(Library.INSTANCE.kMetaTreeNameInvalid()),

    kMetaTreeNameNotExists(Library.INSTANCE.kMetaTreeNameNotExists()),

    kMetaTreeLinkInvalid(Library.INSTANCE.kMetaTreeLinkInvalid()),

    kMetaTreeSubtreeNotExists(Library.INSTANCE.kMetaTreeSubtreeNotExists()),

    kVineyardServerNotReady(Library.INSTANCE.kVineyardServerNotReady()),

    kArrowError(Library.INSTANCE.kArrowError()),

    kConnectionFailed(Library.INSTANCE.kConnectionFailed()),

    kConnectionError(Library.INSTANCE.kConnectionError()),

    kEtcdError(Library.INSTANCE.kEtcdError()),

    kNotEnoughMemory(Library.INSTANCE.kNotEnoughMemory()),

    kStreamDrained(Library.INSTANCE.kStreamDrained()),

    kStreamFailed(Library.INSTANCE.kStreamFailed()),

    kInvalidStreamState(Library.INSTANCE.kInvalidStreamState()),

    kStreamOpened(Library.INSTANCE.kStreamOpened()),

    kGlobalObjectInvalid(Library.INSTANCE.kGlobalObjectInvalid()),

    kUnknownError(Library.INSTANCE.kUnknownError());

    private static final CXXEnumMap<StatusCode> $map = new CXXEnumMap<>(values());

    int $value;

    StatusCode(int value) {
        $value = value;
    }

    StatusCode(CInt value) {
        $value = value.get();
    }

    public static StatusCode get(int value) {
        return $map.get(value);
    }

    public static StatusCode get(CInt value) {
        return $map.get(value.get());
    }

    public int getValue() {
        return $value;
    }

    public static StatusCode cast(final long __foreign_address) {
        try {
            Class<StatusCode> clz = (Class<StatusCode>) FFITypeFactory.getType(FFITypeFactory.getFFITypeName(StatusCode.class, true));
            return clz.getConstructor(Long.TYPE).newInstance(__foreign_address);
        } catch (ClassNotFoundException | NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) {
            return null;
        }
    }

    public static StatusCode cast(final FFIPointer __foreign_pointer) {
        return StatusCode.cast(__foreign_pointer.getAddress());
    }

    @FFIGen
    @FFILibrary(
            value = "vineyard::StatusCode",
            namespace = "vineyard::StatusCode"
    )
    @CXXHead("common/util/status.h")
    public interface Library {
        Library INSTANCE = FFITypeFactory.getLibrary(Library.class);

        @FFIGetter
        int kOK();

        @FFIGetter
        int kInvalid();

        @FFIGetter
        int kKeyError();

        @FFIGetter
        int kTypeError();

        @FFIGetter
        int kIOError();

        @FFIGetter
        int kEndOfFile();

        @FFIGetter
        int kNotImplemented();

        @FFIGetter
        int kAssertionFailed();

        @FFIGetter
        int kUserInputError();

        @FFIGetter
        int kObjectExists();

        @FFIGetter
        int kObjectNotExists();

        @FFIGetter
        int kObjectSealed();

        @FFIGetter
        int kObjectNotSealed();

        @FFIGetter
        int kObjectIsBlob();

        @FFIGetter
        int kMetaTreeInvalid();

        @FFIGetter
        int kMetaTreeTypeInvalid();

        @FFIGetter
        int kMetaTreeTypeNotExists();

        @FFIGetter
        int kMetaTreeNameInvalid();

        @FFIGetter
        int kMetaTreeNameNotExists();

        @FFIGetter
        int kMetaTreeLinkInvalid();

        @FFIGetter
        int kMetaTreeSubtreeNotExists();

        @FFIGetter
        int kVineyardServerNotReady();

        @FFIGetter
        int kArrowError();

        @FFIGetter
        int kConnectionFailed();

        @FFIGetter
        int kConnectionError();

        @FFIGetter
        int kEtcdError();

        @FFIGetter
        int kNotEnoughMemory();

        @FFIGetter
        int kStreamDrained();

        @FFIGetter
        int kStreamFailed();

        @FFIGetter
        int kInvalidStreamState();

        @FFIGetter
        int kStreamOpened();

        @FFIGetter
        int kGlobalObjectInvalid();

        @FFIGetter
        int kUnknownError();
    }
}
